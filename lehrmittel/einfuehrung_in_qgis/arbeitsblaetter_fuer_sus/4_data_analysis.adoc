= Introduction to QGIS 3: Data Analysis (Chapter 4)
OpenSchoolMaps.ch -- Free learning materials for free geodata and maps
:xrefstyle: short
:imagesdir: ../../../bilder/
include::../../../snippets/lang/de.adoc[]
include::../../../snippets/suppress_title_page.adoc[]

*A worksheet*
ifdef::show_solutions[- *SOLUTIONS*]

In the last chapters you've learned how geodata is captured and displayed in a 
GIS. Thus everything is prepared for the "speciality" of GIS, namely the 
derivation of new information from existing spatial data. This derivation of new
information is called *analysis*. 

== Learning objectives

This chapter has the following learning objectives

* State the difference between queries and manipulations in your own words

* List which query types there are and explain them with the help of one example
each

* Formulate a correct SQL query for a thematic query

== Theory
image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 1_ +
_As an introduction to the data analysis chapter, solve the following tasks:_

. Search 1: Go to the homepage http://tel.local.ch/de/ and enter the name and, 
if known, the place of residence of a person you know who might have an entry 
in the phone book (e.g. your parents or grandparents). Then click on the 
search button. What is the result of your search? In which form are the input 
and the output of the search, if you look at the search on the page 
tel.local.ch in general?

. Search 2: Next, go to the homepage http://www.sbb.ch/ and look for the next 
connection from the station closest to your home to Chur. Look again at the 
input and output values. The results themselves are not so important as the 
form in which the results are output. Make some notes about it again.  

. Comparison: What do you notice if you now compare the type of results of 
search 1 and search 2? Write down your findings.

ifdef::show_solutions[]
====
.Solution
*Question 1* +
In order to start a query, you must give name, first name and city into the 
text field. The query could look like this:

.Input for the search on local.ch
image::einfuehrung_in_qgis/abfragefrage1.png["Abfrage Frage1"]

And here is the corresponding result:

.Output for the search on local.ch
image::einfuehrung_in_qgis/ausgabefrage1.png["Ausgabe Frage1"]

The results are returned as address and as a mark on a map.

*Question 2*
To start a query, you have to give start, destination, date and time in the 
fields. The query could look like this:

.Input for the search on sbb.ch
image::einfuehrung_in_qgis/abfragefrage2.png["Abfrage Frage2"]

The result is returned in text form:

.Output for the search on sbb.ch
image::einfuehrung_in_qgis/ausgabefrage2.png["Ausgabe Frage2"]

*Question 3* +
In both searches the input values are in text form.

The results are output once in text form and spatially, in the second search
only in text form.

The first time you search, you often want to know not only which street a 
person lives on or what their telephone number is, but also where they live on 
the map. The map entry can also be helpful if, as in our case, there are 
several Peter Müller in Bern. If you know in which area he lives, you can 
narrow down the search visually.

When it comes to timetable information, the first thing you want to know is 
the departure and arrival times. The spatial component is of secondary 
importance for the result and is therefore not displayed.
====
endif::show_solutions[]

Keep your solutions in your mind. We will come back to them later in 
this chapter.

As already mentioned in the introduction, the derivation of new information 
from existing spatial data is one of the most valuable and most important 
functions of a GIS.

In general, we differentiate between two types of analysis: *queries* and 
*manipulations*. For the queries the data remains unchanged, manipulations 
either change the data or even generate new data.


=== Query

There are three ways in which a query can be executed.

. Queries based on factual data. Example: Select all lakes with a water depth 
greater than 100 meters. These queries are called *thematic queries or 
selections*.

. Query relationships between different geometric objects. Example: Select all 
lakes that are completely within a canton. These queries are called 
*topological queries or selections*.

. Queries about the geometry of objects. Example:  Which main locations are at a 
distance of less than 20 km around Lake Lucerne? These queries are called 
*geometric queries or selections*.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 2_ +
_Consider what kind of queries the introductory exercise was?_

ifdef::show_solutions[]
====
.Solution
Both cases are thematic queries.
====
endif::show_solutions[]

=== Database language SQL 

To perform thematic queries, the database language *SQL (Structured Query 
Language)* is used. If you have already worked with databases, you will 
probably already know the language. Then the next section is Repetition. For 
everyone else it is a short introduction to the most important structures and 
expressions of a query with SQL.

A simplified _SQL query_ is structured as follows:

....
SELECT select-expression
FROM our-table
WHERE where-expression
.... 

Overview of the variables that you should know for simple queries:

*select-expression:*  Names of all attributes, which should be displayed as 
the result of the query. A * means, all attributes are displayed. For thematic 
queries in a GIS this is the only query possible. Therefore, this variable 
must not be set in the GIS.

*our-table:* Name of the table, which contains the attributes needed for the 
query.

*where-expression:* The conditions to filter the data.

Overview over the SQL expressions, which use the where-expression, and their 
meaning.

[%header,cols=2*]
|===
|SQL Expression
|Meaning

|=
|equal

|<
|smaller

|$$<=$$
|smaller or equal.

|>
|greater.

|>=
|greater or equal.

|<>
|not equal, different.

|LIKE
|Comparison of characters. You can use symbols as placeholders: %: Placeholder 
for an unknown amount of characters for example LIKE ,F%' is for all entries 
which begin with the letter F _ : Placeholder for a single character for 
example LIKE ,Me_er', if you're looking for a person and don't know if the 
name is Meyer or Meier. With LIKE ,M_-er' can it also be Mayer. 

|IS NULL
|Cell is empty.

|IS NOT NULL
|Cell is not empty.

|BETWEEN
|between to values.
|===

You can combine different requirements together and use logical Operators
if _Condition 1_ *and* (*AND*) _Condition 2_ 
or _Condition 1_ *or* (*OR*) _Condition 2_
or _Condition 1_ *and not* (*NOT*) _Condition 2_
should be valid.

Here's a wrapup to illustrate everything as a venn diagram:

[cols="1,1a"]
|===

|*AND*-Operator:
Which element belongs both to set A and set B?
|image::einfuehrung_in_qgis/and_operator.jpg["AND Operator", 113, 69]

|*OR*-Operator:
Which element belongs to either set A or set B
|image::einfuehrung_in_qgis/or_operator.jpg["OR Operator", 113, 69]

|*NOT*-Operator:
Which element belongs to set A but not to set B
|image::einfuehrung_in_qgis/not_operator.jpg["NOT Operator", 113, 69]
|===

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 3_ +
_Try it now for yourself and formulate the following query in SQL:_

. All lakes should be selected whose area is greater than 20 km^2^ and which are 
deeper than 400 m.a.s.l..
. _The search that you did as an introduction to theory as Search 1 on the 
homepage http://tel.local.ch/de/._

ifdef::show_solutions[]
====
.Solution 1
....
SELECT
FROM lakes
WHERE surface area > 20 AND depth < 400
....

.Solution 2
....
SELECT
FROM Address
WHERE Name = 'Müller' AND Surname = 'Peter' AND Ort = 'Bern'
....
====
endif::show_solutions[]

== QGIS Exercise

The "speciality" of a GIS should of course not only be thought in theory. 
In this chapter you will perform some thematic and spatial queries.

=== Learning objectives

At the end of this exercise, you've mastered the following points:

* Select elements based on thematic and spatial criteria.
* Calculate a new value for a field from existing values.

=== Thematic selection

At the beginning of this exercise we would like to perform a simple query. You 
already know it from the SQL exercise in the theoretical part:

All lakes should be selected whose area is larger than 20 km^2^ and which are 
deeper than 400 m.a.s.l.

To select these lakes, you could now look through each row of the attribute 
table and determine which objects belong to them and which do not. But if you 
have a lot of objects, this kind of search would quickly take a lot of time.

It's easier if you use the predefined search masks. If you are only looking 
for a name or a number, the easiest way is to use the _Field Filter_ in the 
attribute table.

Try this search with a small example. Open the attribute table of the lakes. 
In the lower left area you will see a line that says _Show All Features_ and a 
menu that you can open. Search in this menu, in the _Field Filter_, for the 
attribute you want to sort by. Additionally, you have to enter the term you 
want to filter by. For example, you want to search for all lakes in which 
"Lago" appears in the name. Select the attribute "name" in the menu at the 
bottom left and search for the term "Lago".

To see immediately how many elements have been selected, you can activate the 
_Show Selected Features_ option.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 4_ + 
_How many solutions Do you get?_

ifdef::show_solutions[]
====
.Solution
Query:

.Input in QGIS
image::einfuehrung_in_qgis/aufgabe4abfrage.png["Aufgabe 4 Abfrage", 612, 36]

Solution:

.The entries shown in QGIS after a query.
image::einfuehrung_in_qgis/aufgabe4ausgabe.png["Aufgabe 4 Ausgabe", 629, 71]
====
endif::show_solutions[]

Let's get back to the opening example. This query is a bit more complicated. 
Open the query editor by clicking the _Select features using an expression_ 
button. Here the query can be formulated in the form of a _SQL_ query. 
However, only the _Where clause_ of the _SQL_ query has to be entered. From 
_Select * from Seen where max_depth > 100_ only the part _max_depth > 100_ has 
to be typed into the query field.

The single components of the where-expression can be composed by 
double-clicking on the window to the right.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 5_ +
_Now formulate the where clause of the SQL query for the entry task and execute 
the query. How many lakes meet these conditions?_

ifdef::show_solutions[]
====
.Solution
....
SELECT
FROM lakes
WHERE surface_area > 20 AND meters_over_seal_level < 400
....
4 lakes
====
endif::show_solutions[]

=== Spatial selection

In the first part of this section a query was created based on values from 
the attribute table. Now a query has to be written which takes the position 
of the object into consideration, also called spatial selection.

You can find the tools for the spatial queries when you click on the button 
_Toolbox_ and select _Select by location_ from _Vector selection_

All cantons are to be selected in which at least one of the lakes lies entirely 
within the canton (i.e. the canton doesn't share the lake with another canton 
or country). 

The _Select features from_ layer gives information from which layer we select 
the elements. 
In this case we select from cantons and because of that we choose the layer 
canton boarders. 
The lakes are noted in the _By comparing to the features from_ layer. 
The box _Selected features only_ needs o e checked so that only the lakes 
with a depth of at least 100 meters are selected.

The lakes should be completely within the boarders of a canton. 
I.e. the cantonal areas fully contain the lake areas. Therefore the topological 
operation _contains_. 
By selecting topological operations one always starts from 
_Select_features from_ and checks how it compares to 
_By comparing to the features from_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 6_ +
_Run the query. How many cantons fulfill the condition?_

ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe6abfrage.png["Exercise 6 query", 470, 374]

Solution:

.Table output from QGIS
image::einfuehrung_in_qgis/aufgabe6ausgabe.png["Exercise 6 query", 828, 189]

8 cantons meet the condition: Bern, Freiburg, Luzern, Obwalden, Schwyz, Waadt, 
Zug und Zürich.
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 7_ +
_How would you need to modify the query if all lakes should be selected which 
are part of more than one canton or country?_
ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe7abfrage.png["Exercise 7 query", 470, 374]
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 8_ +
_How many lakes meet the condition?_

ifdef::show_solutions[]
====
.Solution
Result:

.Output in the table from QGIS
image::einfuehrung_in_qgis/aufgabe8ausgabe.png["Exercise 8 query", 627, 296]

12 lakes meet the condition.
====
endif::show_solutions[]

=== Calculate fields

The next step is to create a new value using existing attributes. More 
precisely, the population density of the cantons is to be calculated. This is 
done using the following formula:

_Population density per km^2^ = Number of inhabitants / surface area in km^2^_

For this calculation, the attribute table of the cantons must be used. Select 
the option _Open field calculator_. If you want to write the density value 
into an already existing column, you can mark _Update existing field_ in the 
mask and select your desired column in the dropdown menu. In our case, 
however, we would like to create a new field. Therefore enter under _Output 
field name_ the term _Density_. Choose as _Output field type integer_ and as 
_Output field length 10_.

If you want to calculate the density value for all and not only for the 
selected cantons, you have to make sure that the cross is not set for _Only 
update x selected features_ .

Now you can formulate the _Field Calculator Expression_ according to the 
population density formula. All you have to do is enter the expression after 
the equal sign.

We would also like to calculate the density as a whole rounded number without 
decimal places. Therefore the option to _Whole number_ must be selected.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 9_ +
_What do you write into the calculator?_

ifdef::show_solutions[]
====
.Solution
to int ( Population / Surface area)
====
endif::show_solutions[]

After the calculation the editing mode must be switched off again. If you are 
satisfied with the calculation then save the changes. If not, reject them.

=== Combined selection

In a further query, determine the names of all the main towns whose associated 
cantons have a population density of more than 200 inhabitants per km^2^ and 
which joined Switzerland between 1800 and 1900.

A query is now to be carried out in which both thematic and spatial components 
play a role.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 10_ +
_Think about which component is thematic and which is spatial._

ifdef::show_solutions[]
====
.Solution
*thematic:*

* Population density of more than 200 inhabitants per km^2^
* joined Switzerland between 1800 and 1900

*spatial:* +
Main towns located in the corresponding cantons.
====
endif::show_solutions[]

For this query we'll do two steps in the first one we'll run the thematic 
query. Open for that the attribute table for cantons and select with help of 
_Select by expression_ all cantons with the population density greater than 
200 people per km^2^ and joined Switzerland between 1800 and 1900.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 11_ +
_What's the where-expression?_

ifdef::show_solutions[]
====
.Solution
....
WHERE Density > 200 AND accession year > 1800 AND accession year < 1900
....
====
endif::show_solutions[]

Now all cantons are selected which fulfill this condition.

After that we need to find the corresponding the main towns, this is done with 
the help of spatial selection. 
For that open the tool _Select by Location_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 12_ +
_Which layer is the *Select features from* layer and which is the *By comparing 
to the features from* layer? Which topological operation has to be chosen?_

ifdef::show_solutions[]
====
.Solution
*Select features from:* main towns +
*By comparing to the features from:* canton borders +

*Topological operation:* within
====
endif::show_solutions[]

Before the execution of the query, check that the options are set, so that 
from the cantonal borders only the selected ones are taken into account.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 13_ +
_Which main towns are the result?_

ifdef::show_solutions[]
====
.Solution
Aarau, Frauenfeld, Genève, Lausanne, Neuchâtel, Sankt Gallen
====
endif::show_solutions[]

== Chapter test 4

=== Question 1

In chapter 4 you have learned to differentiate between to variants of analysis, 
namely queries and manipulations.

_What's the difference between these two variants?_

Write down your answer using your own words and add an example for each.

ifdef::show_solutions[]
====
.Solution
Query: +
A query only accesses the data and does not change it in any form.

For example if you want to know how many people under 30 earn more than 
150'000 CHF per year

Manipulation: +
Manipulation changes or even adds new data.

For example: In an existing transport system you can add a new attribute that 
shows how strong the strain on it is. Another option would be the adding of 
yet untracked routs.
====
endif::show_solutions[]

=== Question 2

You have learned to formulate thematic queries with SQL.

_Create an SQL query for the following question:_ +
_"Which cantons have a population density greater than 200 inhabitants per km^2^,
joined Switzerland before 1600 A.D. and have a name that does not begin with 
the letter Z?"_

Use the simplified version of the SQL query and mark the typical elements of 
it separately. 
The names of the tables and attributes can be taken from the data given to you.

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton +
WHERE Population / Surface area >
200 AND accession_year < 1600
AND Name NOT LIKE ‘Z%’
====
endif::show_solutions[]

=== Question 3

Besides the thematic queries, there are other variants which can be combined.

_For the following question create an SQL-Query:_ +
_"Select all cantons which joined Switzerland after 1600 and have contact 
with a lake greater than 50km^2^"_

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton, lake +
WHERE canton.accession year >
1600 AND lake.Surface area > 50
AND -- TODO
====
endif::show_solutions[]
