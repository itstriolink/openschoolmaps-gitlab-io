= Introduction to QGIS 3: Data Analysis (Chapter 4)
OpenSchoolMaps.ch -- Free learning materials for free geodata and maps
:xrefstyle: short
:imagesdir: ../../../bilder/
include::../../../snippets/lang/de.adoc[]
include::../../../snippets/suppress_title_page.adoc[]

*A worksheet*
ifdef::show_solutions[- *SOLUTIONS*]

In the last chapters you've learned how geodata is captured and displayed in a 
GIS. Thus everything is prepared for the "speciality" of GIS, namely the 
derivation of new information from existing spatial data. This derivation of new
information is called *analysis*. 

== Learning objectives

This chapter has the following learning objectives

* State the difference between queries and manipulations in your own words

* List which query types there are and explain them with the help of one example
each

* Formulate a correct SQL query for a thematic query

== Theory
image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 1_ +
_As an introduction to the data analysis chapter, solve the following tasks:_

. Search 1: Go to the homepage http://tel.local.ch/de/ and enter the name and, 
if known, the place of residence of a person you know who might have an entry 
in the phone book (e.g. your parents or grandparents). Then click on the 
search button. What is the result of your search? In which form are the input 
and the output of the search, if you look at the search on the page 
tel.local.ch in general?

. Search 2: Next, go to the homepage http://www.sbb.ch/ and look for the next 
connection from the station closest to your home to Chur. Look again at the 
input and output values. The results themselves are not so important as the 
form in which the results are output. Make some notes about it again.  

. Comparison: What do you notice if you now compare the type of results of 
search 1 and search 2? Write down your findings.

ifdef::show_solutions[]
====
.Solution
*Question 1* +
In order to start a query, you must give name, first name and city into the 
text field. The query could look like this:

.Input for the search on local.ch
image::einfuehrung_in_qgis/abfragefrage1.png["Abfrage Frage1"]

And here is the corresponding result:

.Output for the search on local.ch
image::einfuehrung_in_qgis/ausgabefrage1.png["Ausgabe Frage1"]

The results are returned as address and as a mark on a map.

*Question 2*
To start a query, you have to give start, destination, date and time in the 
fields. The query could look like this:

.Input for the search on sbb.ch
image::einfuehrung_in_qgis/abfragefrage2.png["Abfrage Frage2"]

The result is returned in text form:

.Output for the search on sbb.ch
image::einfuehrung_in_qgis/ausgabefrage2.png["Ausgabe Frage2"]

*Question 3* +
In both searches the input values are in text form.

The results are output once in text form and spatially, in the second search
only in text form.

The first time you search, you often want to know not only which street a 
person lives on or what their telephone number is, but also where they live on 
the map. The map entry can also be helpful if, as in our case, there are 
several Peter Müller in Bern. If you know in which area he lives, you can 
narrow down the search visually.

When it comes to timetable information, the first thing you want to know is 
the departure and arrival times. The spatial component is of secondary 
importance for the result and is therefore not displayed.
====
endif::show_solutions[]

Keep your solutions in your mind. We will come back to them later in 
this chapter.

As already mentioned in the introduction, the derivation of new information 
from existing spatial data is one of the most valuable and most important 
functions of a GIS.

In general, we differentiate between two types of analysis: *queries* and 
*manipulations*. For the queries the data remains unchanged, manipulations 
either change the data or even generate new data.


=== Query

There are three ways in which a query can be executed.

. Queries based on factual data. Example: Select all lakes with a water depth 
greater than 100 meters. These queries are called *thematic queries or 
selections*.

. Query relationships between different geometric objects. Example: Select all 
lakes that are completely within a canton. These queries are called 
*topological queries or selections*.

. Queries about the geometry of objects. Example:  Which main locations are at a 
distance of less than 20 km around Lake Lucerne? These queries are called 
*geometric queries or selections*.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 2_ +
_Consider what kind of queries the introductory exercise was?_

ifdef::show_solutions[]
====
.Solution
Both cases are thematic queries.
====
endif::show_solutions[]

=== Database language SQL 

To perform thematic queries, the database language *SQL (Structured Query 
Language)* is used. If you have already worked with databases, you will 
probably already know the language. Then the next section is Repetition. For 
everyone else it is a short introduction to the most important structures and 
expressions of a query with SQL.

A simplified _SQL query_ is structured as follows:

....
SELECT select-expression
FROM our-table
WHERE where-expression
.... 

Overview of the variables that you should know for simple queries:

*select-expression:*  Names of all attributes, which should be displayed as 
the result of the query. A * means, all attributes are displayed. For thematic 
queries in a GIS this is the only query possible. Therefore, this variable 
must not be set in the GIS.

*our-table:* Name of the table, which contains the attributes needed for the 
query.

*where-expression:* The conditions to filter the data.

Overview over the SQL expressions, which use the where-expression, and their 
meaning.

[%header,cols=2*]
|===
|SQL Expression
|Meaning

|=
|equal

|<
|smaller

|$$<=$$
|smaller or equal.

|>
|greater.

|>=
|greater or equal.

|<>
|not equal, different.

|LIKE
|Comparison of characters. You can use symbols as placeholders: %: Placeholder 
for an unknown amount of characters for example LIKE ,F%' is for all entries 
which begin with the letter F _ : Placeholder for a single character for 
example LIKE ,Me_er', if you're looking for a person and don't know if the 
name is Meyer or Meier. With LIKE ,M_-er' can it also be Mayer. 

|IS NULL
|Cell is empty.

|IS NOT NULL
|Cell is not empty.

|BETWEEN
|between to values.
|===

You can combine different requirements together and use logical Operators
if _Condition 1_ *and* (*AND*) _Condition 2_ 
or _Condition 1_ *or* (*OR*) _Condition 2_
or _Condition 1_ *and not* (*NOT*) _Condition 2_
should be valid.

Here's a wrapup to illustrate everything as a venn diagram:

[cols="1,1a"]
|===

|*AND*-Operator:
Which element belongs both to set A and set B?
|image::einfuehrung_in_qgis/and_operator.jpg["AND Operator", 113, 69]

|*OR*-Operator:
Which element belongs to either set A or set B
|image::einfuehrung_in_qgis/or_operator.jpg["OR Operator", 113, 69]

|*NOT*-Operator:
Which element belongs to set A but not to set B
|image::einfuehrung_in_qgis/not_operator.jpg["NOT Operator", 113, 69]
|===

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 3_ +
_Try it now for yourself and formulate the following query in SQL:_

. _Select every lake with a surface area larger than 20km^2^ and which lies_ 
_below 400 meters above sea-level._
. _The search that you did as introduction in the Search 1 at homepage of_
_http://tel.local.ch/de/ ._

ifdef::show_solutions[]
====
.Solution 1
....
SELECT
FROM lakes
WHERE surface area > 20 AND depth < 400
....

.Solution 2
....
SELECT
FROM Address
WHERE Name = 'Müller' AND Surname = 'Peter' AND Ort = 'Bern'
....
====
endif::show_solutions[]

== QGIS Exercise

The "speciality" of a GIS should of course not only be thought in theory. 
In this chapter you will perform some thematic and spatial queries.

=== Learning objectives

At the end of this exercise, you've mastered the following points:

* Select elements based on thematic and spatial criteria.
* Calculate a new value for a field from existing values.

=== Thematic selection

At the beginning of this exercise we would like to perform a simple query that 
you already know from the SQL exercise in the theory part:

_You should select every lake which has a surface area above 20 km^2^ and _
_which lies below 400 meter above sea-level._

You could look through each cell in the attribute table and check which ones fit 
the criteria and which do not. 
However, if you have a large table, that becomes rather time intensive.

It's simpler to use the prepared search interface. For simple searches like a 
name it's easiest to use _Field Filter_ in the table.

Try this method in a small example. Open the attribute table for lakes. 
In the lower left area you see a line on which _Show All Features_ is written 
and a menu, that you can unfold. 
Search in this menu, in the _Field Filter_, for the attribute, for which you 
want to sort out. 
In addition, you must enter the term you want to filter. 
You want now for example search for all lakes with name "Lago" appears. 
Choose the attribute "name" in the menu and search for the term "Lago".

In order to can see immediately how many elements were selected, you can 
activate the option _Show Selected Features_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 4_ + 
_How many solutions Do you get?_

ifdef::show_solutions[]
====
.Solution
Query:

.Input in QGIS
image::einfuehrung_in_qgis/aufgabe4abfrage.png["Aufgabe 4 Abfrage", 612, 36]

Solution:

.The entries shown in QGIS after a query.
image::einfuehrung_in_qgis/aufgabe4ausgabe.png["Aufgabe 4 Ausgabe", 629, 71]
====
endif::show_solutions[]

Let us get back to the initial example. 
This query is a little more complicated. 
Open by clicking on the button _Select features using an expression_ in the 
query editor. 
Here the query can be expressed in the form of an _SQL_ query. 
However, only the _Where clause_ of the _SQL_ query can be inserted. 
From the query _select * from lakes where max_depth > 100_ only 
_max_depth > 100_ have to be written into the query field.

The single components of the where-expression can be composed by 
double-clicking on the window to the right.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 5_ +
_Formulate the where-clause of the SQL query for the initial task and run _
_the query. How many lakes meet these conditions?_

ifdef::show_solutions[]
====
.Solution
....
SELECT
FROM lakes
WHERE surface_area > 20 AND meters_over_seal_level < 400
....
4 lakes
====
endif::show_solutions[]

=== Spatial selection

In the first part of this section a query was created based on values from 
the attribute table. Now a query has to be written which takes the position 
of the object into consideration, also called spatial selection.

You can find the tools for the spatial queries when you click on the button 
_Toolbox_ and select _Select by location_ from _Vector selection_

All cantons are to be selected in which at least one of the lakes lies entirely 
within the canton (i.e. the canton doesn't share the lake with another canton 
or country). 

The _Select features from_ layer gives information from which layer we select 
the elements. 
In this case we select from cantons and because of that we choose the layer 
canton boarders. 
The lakes are noted in the _By comparing to the features from_ layer. 
The box _Selected features only_ needs o e checked so that only the lakes 
with a depth of at least 100 meters are selected.

The lakes should be completely within the boarders of a canton. 
I.e. the cantonal areas fully contain the lake areas. Therefore the topological 
operation _contains_. 
By selecting topological operations one always starts from 
_Select_features from_ and checks how it compares to 
_By comparing to the features from_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 6_ +
_Run the query. How many cantons fulfill the condition?_

ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe6abfrage.png["Aufgabe 6 Abfrage", 470, 374]

Lösung:

.Table output from QGIS
image::einfuehrung_in_qgis/aufgabe6ausgabe.png["Aufgabe 6 Ausgabe", 828, 189]

8 cantons meet the condition: Bern, Freiburg, Luzern, Obwalden, Schwyz, Waadt, 
Zug und Zürich.
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 7_ +
_How would you need to modify the query if all lakes should be selected which_
_are part of more than one canton or country?_
ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe7abfrage.png["Aufgabe 7 Abfrage", 470, 374]
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 8_ +
_How many lakes meet the condition._

ifdef::show_solutions[]
====
.Solution
Result:

.Output in the table from QGIS
image::einfuehrung_in_qgis/aufgabe8ausgabe.png["Aufgabe 8 Abfrage", 627, 296]

12 lakes meet the condition.
====
endif::show_solutions[]

=== Calculate fields

Next a new value can be generated with the help of existing attributes. 
In this case, the population density of the cantons needs to be calculated.
We do thus using the following formula:

_Population density per km^2^ = Number of inhabitants / surface area in km^2^_

For this calculation we'll need the attribute table of the cantons. 
Select the option _Open field calculator_. 
If you want to write the density value into an existing column, you can check 
_Update existing field_ in the mask, and you can select your desired column
in the drop down menu. 
In our case, however, we would like to create a new field. 
Therefore enter _Output field name_ enter the term _density_. 
Select as _Output field type Integer (integer)_ and as _Output field length 10_.

If you want to calculate the density value for all and not only for the 
selected cantons, you have to be careful, that 
_Only update x selected features_ is not checked.

Now you can use the _Field Calculator Expression_ according to the formula for 
the population density. 
All you have to do is put in the expression after the equal sign.

We would also like to calculate the density as a whole rounded number without 
decimal point. 
Therefore the option to _Whole number_ can be selected.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 9_ +
_What do you write into the calculator?_

ifdef::show_solutions[]
====
.Solution
to int ( Population / Surface area)
====
endif::show_solutions[]

After the calculation the editing mode must be switched off again. If you are 
satisfied with the calculation then save the changes. If not, reject them.

=== Combined selection

Determine in another query the names of all major locations, their associated 
cantons which have a population density of more than than 200 inhabitants per 
km^2^ and have joined Switzerland between 1800 and 1900.

Now a query should be executed, in which both thematic and spartial components 
are involved.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 10_ +
_Think about which component is thematic and which is spatial._

ifdef::show_solutions[]
====
.Solution
*thematic:*

* Population density of more than 200 inhabitants per km^2^
* joined Switzerland between 1800 and 1900

*spatial:* +
Main towns located in the corresponding cantons.
====
endif::show_solutions[]

For this query we'll do two steps in the first one we'll run the thematic 
query. Open for that the attribute table for cantons and select with help of 
_Select by expression_ all cantons with the population density greater than 
200 people per km^2^ and joined Switzerland between 1800 and 1900.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 11_ +
_What's the where-expression?_

ifdef::show_solutions[]
====
.Solution
....
WHERE Density > 200 AND accession year > 1800 AND accession year < 1900
....
====
endif::show_solutions[]

Now all cantons are selected which fulfill this condition.

After that we need to find the corresponding the main towns, this is done with 
the help of spatial selection. 
For that you open the tool _Select by Location_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 12_ +
_Which layer is now the *Select features from* layer_
_and which one the *By comparing to the features from* layer?_ 
_Which topological surgery should be chosen?_

ifdef::show_solutions[]
====
.Solution
*Select features from:* main towns +
*By comparing to the features from:* canton borders +

*Topologische Operation:* within
====
endif::show_solutions[]

Before the execution of the query, check that the options are set, so that 
from the cantonal borders only the selected ones are taken into account.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 13_ +
_Which main towns are the result?_

ifdef::show_solutions[]
====
.Solution
Aarau, Frauenfeld, Genève, Lausanne, Neuchâtel, Sankt Gallen
====
endif::show_solutions[]

== Chapter test 4

=== Question 1

In chapter 4 you have learned to differentiate between to variants of analysis, 
namely queries and manipulations.

_What's the difference between these two variants._

Write down your answer using your own words and add an example for each.

ifdef::show_solutions[]
====
.Solution
Query: +
A query only accesses the data and does not change it in any form.

For example if you want to know how many people under 30 earn more than 
150'000 CHF per year

Manipulation: +
Manipulation changes or even adds new data.

For example: In an existing transport system you can add a new attribute that 
shows how strong the strain on it is. Another option would be the adding of 
yet untracked routs.
====
endif::show_solutions[]

== Question 2

You have learned to formulate thematic queries with SQL.

_Create an SQL query for the following question:_+
_"Which cantons have a greater population density than 200 people per km^2^, _
_joined Switzerland before the year 1600, and whose name doesn't start with a Z?_

Use the simplified version of the SQL query and mark the typical elements of 
it separately. 
The names of the tables and Attributes can be taken from the data given to you.

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton +
WHERE Population / Surface area >
200 AND accession_year < 1600
AND Name NOT LIKE ‘Z%’
====
endif::show_solutions[]

=== Question 3

Besides the thematic queries, there are other variants which can be combined.

_For the following question create an SQL-Query:_ +
_"Select all cantons which joined Switzerland after 1600 and have contact _
_with a lake greater then 50km^2^._

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton, lake +
WHERE canton.accession year >
1600 AND lake.Surface area > 50
AND -- TODO
====
endif::show_solutions[]
