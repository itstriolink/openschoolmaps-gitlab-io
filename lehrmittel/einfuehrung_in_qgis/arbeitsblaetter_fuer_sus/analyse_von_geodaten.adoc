= Introduction to QGIS 3: Data Analysis (Chapter 4)

../../../snippets/suppress_title_page.adoc

*A worksheet*
ifdef::show_solutions[- *Solutions*]

In the last chapters you've learned, how geodata is captured and can be displayed in a GIS. Thus everything is prepared for the "speciality" of GIS, namely the derivation of new information from existing spatial data. This derivation of new information is called *analysis*.

== Learning objectives

This chapter has the following objectives

* State  the difference between queries and manipulations in one's own words

* List, which query types exist and to explain those with the help of an example

* For a thematic query formulate a correct SQL query

== Theory

_Exercise 1_ +

_As introduction for this chapter solve the folowing Exercises:_

. 1. Search 1: Call the websiete http://tel.local.ch/de/ and enter the name and if possible the adress of a person which you know and could have an entry in the phone book (for example your parents). Finish by pressing the search button. What is the result of your search? In what form are both the inputs and outputs of the website?

. 2. Search 2: Next call the website http://www.sbb.ch/ and search for the next connection between the nearest train station and Chur. Again pay attention to the output and input values. The result isn't as important as teh Format. Add these observations to your notes.

. 3. Compare: What do you notice when you compare the form of both results, write down your observations.

ifdef::show_solutions[]
====
.Solution
*Question 1* +
In order to start a query, you must
give name, first name and city into the textfield. The query could look like this:

.Input for the search on local.ch
image::einfuehrung_in_qgis/abfragefrage1.png["Abfrage Frage1"]

And here the coresponding result:

.Output for the search on local.ch
image::einfuehrung_in_qgis/ausgabefrage1.png["Ausgabe Frage1"]

The results are returned as adress and as a mark on a map.

*Qestion 2*
To start a query, you have to
give start,
destination, date and time in the fields. The query could be like
looks like:

.Input for the search on sbb.ch
image::einfuehrung_in_qgis/abfragefrage2.png["Abfrage Frage2"]

The result is returned in textform:

.Output for the search on sbb.ch
image::einfuehrung_in_qgis/ausgabefrage2.png["Ausgabe Frage2"]

*Question 3* +
In both searches, the input values are in text form.

The results are displayed once in text form.
and spatially displayed, the second
Search only gives it in text form.

In the first search you would like to
often not only know at which
street a person lives on or
what her phone number is,
but also where the place of residence is located 
on the map. In addition a 
map entry may be helpful if
as in our case, there are several
Peter Müller in Bern. If
you know what area he's in.
you can search for the
visually.

For the timetable information
the first thing you have to do is departure
and arrival times. The
map is not included in the
result of secondary importance.
====
endif::show_solutions[]

Keep your solutions in the back of my mind. We will later in this chapter come back to them.

As already mentioned in the introduction, the derivation of new information from existing spatial data is one of the most valuable and most important functions of a GIS.

In general we differentiate between two types of analysis: *Queries* and *manipulations*. For the queries the data remains unchanged, manipulations either change the data or even generated new data.


=== Query

There are three points of view according to which a query can be carried out.

. Queries based on factual data. Example: Select all lakes, that have a water depth, that's lower then 100 meters. These queries are thematic queries or selections.

. Queries based on relationships between different geometric objects. Example: Select all lakes, which are completely of a canton. These queries are topological queries or selections.

. Queries via the geometry of the objects. Example: Which main locations lie at a distance of less than 20 km around Lake Lucerne. These queries are geometric queries or selections.


image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 2_

Think about what type of queries you used in the introduction.

ifdef::show_solutions[]
====
.Solution
Both of them are thematic queries.
====
endif::show_solutions[]

=== Database language SQL 

We use *SQL (Structured Query Language)* to run thematic queries. If you already worked with databases, then you wil already know about it and the next step is a simple revision, for all others its a short introduction into the most imperotant structural elements and terms of an SQL query.

A simplified _SQL query_ is structured as follows:

....
SELECT select-expression
FROM our-table
WHERE where-expression
.... 

Overview of the variables which you should know for simple queries:

*select-expression:* Names of all attributes, which should be displayed as the result of the query* means, all attributes are displayed. For thematic queries in a GIS this is the  only query possible. Therefore, this variable must not be set in the GIS.

*our-table:* Name of the table, which contains the attributes need for the query.

*where-expression:* The requirment the data needs to have.

Overview over the SQL-Expressions which use the where-klausel and their meaning.

[%header,cols=2*]
|===
|SQL Expression
|Meaning

|=
|equal

|<
|smaller

|$$<=$$
|smaller or equal

|>
|greater

|>=
|greater or  equal

|<>
|not equal, different

|LIKE
|Comparison of characters. You can use symbols as placeholders:
%: Placeholder for an unknown amount of characters
for example LIKE ,F%' is for all entries which begin with the letter F
_ : Placeholder for a single character
for example LIKE ,Me_er', if you're looking for a person and don't know if the name is Meyer or Meier.
Bei LIKE ,M_-er' can it also be Mayer 

|IS NULL
|Cell is empty

|IS NOT NULL
|Cell is not empty

|BETWEEN
|between to values
|===

You can combine diffrent requirments together and use logical Operators
if _Condition 1_ *and* (*AND*) _Condition 2_ 
*or* _Condition 1_ or (*OR*) _Condition 2_
*or* _Condition 1_ *and not* (*NOT*) -Condition 2_
should be valid.

Here for illustration the hole thing again as a Venn-Diagramm

[cols="1,1a"]
|===

|*AND*-Operator:
Which element belongs both to Group A and Group B
|image::einfuehrung_in_qgis/and_operator.jpg["AND Operator", 113, 69]

|*OR*-Operator:
Whcih element belongs to either Group A or Group B
|image::einfuehrung_in_qgis/or_operator.jpg["OR Operator", 113, 69]

|*NOT*-Operator:
Which element belongs to Group A but not to Group B
|image::einfuehrung_in_qgis/not_operator.jpg["NOT Operator", 113, 69]
|===

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Excersise 3_ +
_Try it now for yourself and formulate the following query in SQL:_

. _Select every lake with a surface area larger then 20km^2^ and lie below 400 meters above sealevel._
. _The search that you did as introduction in the Search 1 on local.ch._

ifdef::show_solutions[]
====
.Solution 1
....
SELECT
FROM seen
WHERE Flaeche > 20 AND Tiefe < 400
....

.Solution 2
....
SELECT
FROM Adressen
WHERE Name = 'Müller' AND Vorname = 'Peter' AND Ort = 'Bern'
....
====
endif::show_solutions[]

== QGIS-Exercise

The "speciality" of a GIS
should of course not only be thaught 
in theory.
In this chapter you will perform 
some thematic
and spatial queries.

=== Objectives

At the end of this exercise.
you've mastered the following points:

* Select elements based on
from thematic
and spatial
criteria
* Calculate a new value for a field from existing values

=== Thematic selection

At the beginning of this exercise
we would like to perform a simple query
that you already know from the SQL exercise
in the theory part:

_You should select every lake which has a surface area above 20 km^2^ and a lie below 400 meter above sealevel._

You could look threw each cell in the Attributstable and check which ones fit the criteria and which don't.
But if you have a large table that becomes rather time intensive.

It's simpler to use the prepared search interface. For simple searches like a name it's easiest o use _Field Filter_ in the table.

Try this method in a small example.
Open the attribute table for lakes.
In the lower left area
you see a line
on which _Show All Features_ is written
and a menu,
that you can unfold.
Search in this menu,
in the _Field Filter_,
forthe attribute,
after which you want to sort out.
In addition, you must enter the term,
you want to filter by. You want now for example
search for all lakes, in which the name "Lago" appears. Choose the attribute "name".
in the menu and search for
the term Lago.

So you can see right away,
how many elements were selected,
you can activate the option
_Show Selected Features_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
task 4_ +
How many solutions
Do you get?_

ifdef::show_solutions[]
====
.Solution
Query:

.Input in QGIS
image::einfuehrung_in_qgis/aufgabe4abfrage.png["Aufgabe 4 Abfrage", 612, 36]

Lösung:

.The returned entries in QGIS
image::einfuehrung_in_qgis/aufgabe4ausgabe.png["Aufgabe 4 Ausgabe", 629, 71]
====
endif::show_solutions[]

But let's get back to the initial example.
This query is a little more complicated.
Open by clicking on the button
_Select features using an expression_
the query editor.
Here the query can be formulated 
in the form of a _SQL_ query.
However, only the _Where clause_
of the _SQL_ query can be inserted.
From _Select * from lakes where max_depth > 100_ so only _max_depth > 100_
can be written into the query field

The single components of teh Where-Clausel can be put together, via doublecklicking on the windows to the right.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 5_ +
_Formulate the where-clause
of the SQL query
for the initial task
and run the query.
How many lakes
meet these conditions?_

ifdef::show_solutions[]
====
.Solution
....
SELECT
FROM seen
WHERE Flaeche > 20 AND Hoehe_muM < 400
....
4 Seen
====
endif::show_solutions[]

=== Spatial selection

In the first part
of this section  a query was created based on values from the attribute table. Now a query should be run which takes the position of the object into consideration, also called spatial selection.


You can find the tools for the spartial queries when you click on the button _Toolbox_ and selecting _Select by location_ from _Vector selection_

All the cantons should
be selected, which contain at least on of the found lakes completly.
(i.e. the canton doesn't share the lack with another canton or country.)

The _Select features from_ Layer 
gives information from which layer we select the elements. In this case we select from cantons and because of that we choose the layer Kantonsgrenzen. The lakes are noted in the _By comparing to the features from_ layer.
Check the box _Selected features only_ so that only the correct lakes are selected.

The lakes should be
completely within the boarders
of a canton.
I.e. the cantonal areas
contain the lake areas.
Therefore
the topological operation _contains_.
By selecting torpological operations one always takes from _Select features from_ and checks how it compares to _By comapring to the features from_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_.Exercise 6_ +
_Run the query. How many cantons fulfill the condition

ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe6abfrage.png["Aufgabe 6 Abfrage", 470, 374]

Lösung:

.Tabel output from QGIS
image::einfuehrung_in_qgis/aufgabe6ausgabe.png["Aufgabe 6 Ausgabe", 828, 189]

8 cantons meet the condition:
Bern, Freiburg, Luzern, Obwalden,
Schwyz, Waadt, Zug und Zürich.
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_.Exercise 7_ +
_How would you need to modify the query if all lakes should be selected which are part of more then one canton or country?_

ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe7abfrage.png["Aufgabe 7 Abfrage", 470, 374]
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_.Exercise 8_ +
_How many lakes meet the condition._

ifdef::show_solutions[]
====
.Solution
Result:

.Output in the table from QGIS
image::einfuehrung_in_qgis/aufgabe8ausgabe.png["Aufgabe 8 Abfrage", 627, 296]

12 Lakes meet the condition.
====
endif::show_solutions[]

=== Calculate fields

Next a new value can be generated, 
with the help of
of existing attributes..
To be more precise
the population density
of the cantons.
This is done by
has the following formula:

_Population density per
km^2^ = Number of inhabitants
/ Surface area in km^2^_

For this calculation
we'll need the attribute table
of the cantons.
Select the option _Open field calculator_.
If you want to use the density value
into an existing column
you can check 
_Update existing field_ in the mask
and in the dropdown menu
select your desired column.
In our case, however, we would like to
create a new field.
Therefore enter _Output field name_
enter the term _density_.
Select as _Output field type
Integer (integer)_
and as _Output field length 10_.

if you want to calculate the density value 
for all and not only
for the selected cantons,
You have to be careful,
that _Only update x selected features_
is not checked.

Now you can use
the _Field Calculator Expression_
according to the formula
for the population density.
All you have to do is put in
the expression after
the equal sign.

We would also like to caluclate
the density
as a whole rounded number
without decimal point.
Therefore
the option to _Whole number_
can be selected.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 9_ +
_What do you write into the calculator?_

ifdef::show_solutions[]
====
.Solution
to int ( Einwohner / Flaeche)
====
endif::show_solutions[]

After the calculation
the editing mode must be
switched off again.
If you are satisfied with the calculation
then save the changes.
If not reject them.

=== Combined selection

Determine in another query
the names of all major locations,
their associated cantons which have
a population density of more than
than 200 inhabitants per km^2^ 
and have joined Switzerland between 1800
and 1900.

Now a query should be executed,
in which both thematic and spartial components are involved.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 10_ +
_Think about which component is thematic and which is spartial._

ifdef::show_solutions[]
====
.Solution
*thematic:*

* Population density of more than
200 inhabitants per km^2^
* joined Switzerland between 1800 and 1900

*spartial:* +
Main towns located in the corresponding cantons.
====
endif::show_solutions[]

for this query we'll do two steps
in the first one we'll run the thematic query.
Open for that the attribute table for cantons
and select with help of _Select by expression_ all cantons
With the population density greater then 200 People pro km^2^ and joined Switzerland between 1800 and 1900.

mage:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 11_ +
_How goes the where-clausel?_

ifdef::show_solutions[]
====
.Solution
....
WHERE Dichte > 200 AND Beitrittsj > 1800 AND Beitrittsj < 1900
....
====
endif::show_solutions[]

Now, all cantons are selected, which who fulfill this condition.

After that we need to find the coresponding the main towns, this is done with the help of spartial selection.
For that you open the tool _Select by Location_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 12_ +
_Which layer is now the
*Select features from*-Layer
andwhich one the
*By comparing to the features from*-Layer?
Which Topological Surgery
should be chosen?_

ifdef::show_solutions[]
====
.Solution
*Select features from:* main towns +
*By comparing to
the features from:* canton borders +

*Topologische Operation:* within
====
endif::show_solutions[]

Before
the execution of the query check ,
that the attitudes are set so,
that from the cantonal borders
only the selected ones
are taken into account.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 13_ +
_Which main towns are the result?_

ifdef::show_solutions[]
====
.Solution
Aarau, Frauenfeld, Genève, Lausanne, Neuchâtel, Sankt Gallen
====
endif::show_solutions[]

== Chapter test 4

=== Question 1

In chapter 4 you have learned to differentiate between to variants of analysis namely queries and manipulations.

_What's the diffrence between this two variants._

Write down your answer using your own words and add an example for each.

ifdef::show_solutions[]
====
.Solution
Query: +
A query only accesses the data
and does not change it in any form

For example if you want to know how many people under 30 earn more then 150'000 CHF per year

Manipulation: +
Manipulation changes or even adds new Data.

For example in an existing transport system
you can add a new attribute that shows how strong the strain on it is.
Another option would be the adding of yet untracked routs.
====
endif::show_solutions[]

== Question 2

You have learned to formulate thematic queries with SQL.

_Create an SQL query for the following question:_+
_"Which cantons have a greater population density then 200 people per km^2^,
joined switzerland before the year 1600 and whose name doesn't start with a Z?_


Use the simplified version of the SQL-guery and mark the typical elements of it seperatly.
The names of the tables and Attributes can be taken from the data given to you.

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton +
WHERE Population / SurfaceArea >
200 AND JoiningYear < 1600
AND Name NOT LIKE ‘Z%’
====
endif::show_solutions[]

=== Question 3

Besides the thematic queries, their are other variants which can be combined.

_For the following question create an SQL-Query:_ +
_"Select all cantons which joind switzerland after 1600 and have contact with a lake greater then 50km^2^._

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton, lake +
WHERE canton.JoiningYear >
1600 AND lake.SurfaceArea > 50
AND -- TODO
====
endif::show_solutions[]
