= Introduction to QGIS 3: Data Analysis (Chapter 4)
../../../snippets/suppress_title_page.adoc
:xrefstyle: short
:imagesdir: ../../../bilder/
include::../../../snippets/lang/de.adoc[]
include::../../../snippets/suppress_title_page.adoc[]

*A worksheet*
ifdef::show_solutions[- *SOLUTIONS*]

In the last chapters you've learned, how geodata is captured and can be 
displayed in a GIS. Thus, everything is prepared for the "specialty" of GIS, 
namely the derivation of new information from existing spatial data. This 
derivation of new information is called *analysis*. 

== Learning objectives

This chapter has the following objectives

* State the difference between queries and manipulations in one's own words

* List, which query types exist and to explain those with the help of an example

* Formulate a correct thematic SQL query

== Theory

_Exercise 1_ +

_As introduction for this chapter solve the folowing Exercises:_

. Search 1: Call the website http://tel.local.ch/de/ and enter the name and if 
possible the address of a person that you know and could have an entry in the 
phone book (for example your parents). Finish by pressing the search button. 
What is the result of your search? In what form are both the inputs and 
outputs of the website?

. Search 2: Next call the website http://www.sbb.ch/ and search for the next 
connection between the nearest train station and Chur. Again, pay attention to 
the output and input values. The result isn't as important as the Format. Add 
these observations to your notes.

. Compare: What do you notice when you compare the form of both results, write 
down your observations.

ifdef::show_solutions[]
====
.Solution
*Question 1* +
In order to start a query, you must
give name, first name and city into the text field. The query could look like 
this:

.Input for the search on local.ch
image::einfuehrung_in_qgis/abfragefrage1.png["Abfrage Frage1"]

And here the corresponding result:

.Output for the search on local.ch
image::einfuehrung_in_qgis/ausgabefrage1.png["Ausgabe Frage1"]

The results are returned as address and as a mark on a map.

*Question 2*
To start a query, you have to
give start,
destination, date and time in the fields. The query could be like
looks like:

.Input for the search on sbb.ch
image::einfuehrung_in_qgis/abfragefrage2.png["Abfrage Frage2"]

The result is returned in text form:

.Output for the search on sbb.ch
image::einfuehrung_in_qgis/ausgabefrage2.png["Ausgabe Frage2"]

*Question 3* +
In both searches, the input values are in text form.

The results are displayed once in text form and spatially displayed, the 
second Search only gives it in text form.

In the first search you would like to often not only know at which street a 
person lives on or what her phone number is, but also where the place of 
residence is located on the map. In addition a map entry may be helpful if as 
in our case, there are several Peter Müller in Bern. If you know what area 
he's in. you can search for the visually.

For the timetable information the first thing you have to do is departure and 
arrival times. The map is not included in the result of secondary importance.
====
endif::show_solutions[]

Keep your solutions in the back of my mind. We will come back to them later in 
this chapter.

As already mentioned in the introduction, the derivation of new information 
from existing spatial data is one of the most valuable and most important 
functions of a GIS.

In general we differentiate between two types of analysis: *Queries* and 
*manipulations*. For the queries the data remains unchanged, manipulations 
either change the data or even generated new data.


=== Query

A query can be carried out according to three points of view.

. Queries based on factual data. Example: Select all lakes that have a water 
depth, that's lower than 100 meters. These queries are thematic queries or 
selections.

. Queries based on relationships between different geometric objects. Example: 
Select all lakes, which are completely of a canton. These queries are 
topological queries or selections.

. Queries via the geometry of the objects. Example: Which main locations lie at 
a distance of less than 20 km around Lake Lucerne. These queries are geometric 
queries or selections.


image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 2_

Think about what type of queries you used in the introduction.

ifdef::show_solutions[]
====
.Solution
Both of them are thematic queries.
====
endif::show_solutions[]

=== Database language SQL 

We use *SQL (Structured Query Language)* to run thematic queries. If you 
already worked with databases, then you will already know about it and the 
next step is a simple revision, for all others its a short introduction into 
the most important structural elements and terms of an SQL query.

A simplified _SQL query_ is structured as follows:

....
SELECT select-expression
FROM our-table
WHERE where-expression
.... 

Overview of the variables that you should know for simple queries:

*select-expression:* Names of all attributes, which should be displayed as the 
result of the query* means, all attributes are displayed. For thematic queries 
in a GIS this is the only query possible. Therefore, this variable must not be 
set in the GIS.

*our-table:* Name of the table, which contains the attributes need for the 
query.

*where-expression:* The requirement the data needs to have.

Overview over the SQL-Expressions, which use the where-expression and their 
meaning.

[%header,cols=2*]
|===
|SQL Expression
|Meaning

|=
|equal

|<
|smaller

|$$<=$$
|smaller or equal

|>
|greater

|>=
|greater or equal

|<>
|not equal, different

|LIKE
|Comparison of characters. You can use symbols as placeholders: %: Placeholder 
for an unknown amount of characters for example LIKE ,F%' is for all entries 
which begin with the letter F _ : Placeholder for a single character for 
example LIKE ,Me_er', if you're looking for a person and don't know if the 
name is Meyer or Meier. With LIKE ,M_-er' can it also be Mayer 

|IS NULL
|Cell is empty

|IS NOT NULL
|Cell is not empty

|BETWEEN
|between to values
|===

You can combine different requirements together and use logical Operators
if _Condition 1_ *and* (*AND*) _Condition 2_ 
*or* _Condition 1_ or (*OR*) _Condition 2_
*or* _Condition 1_ *and not* (*NOT*) -Condition 2_
should be valid.

Here for illustration the hole thing again as a Venn-Diagram

[cols="1,1a"]
|===

|*AND*-Operator:
Which element belongs both to Group A and Group B
|image::einfuehrung_in_qgis/and_operator.jpg["AND Operator", 113, 69]

|*OR*-Operator:
Which element belongs to either Group A or Group B
|image::einfuehrung_in_qgis/or_operator.jpg["OR Operator", 113, 69]

|*NOT*-Operator:
Which element belongs to Group A but not to Group B
|image::einfuehrung_in_qgis/not_operator.jpg["NOT Operator", 113, 69]
|===

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise  3_ +
_Try it now for yourself and formulate the following query in SQL:_

. _Select every lake with a surface area larger then 20km^2^ and lie below 400_ 
_meters above sea-level._
. _The search that you did as introduction in the Search 1 on local.ch._

ifdef::show_solutions[]
====
.Solution 1
....
SELECT
FROM lakes
WHERE surface area > 20 AND depth < 400
....

.Solution 2
....
SELECT
FROM Address
WHERE Name = 'Müller' AND Surname = 'Peter' AND Ort = 'Bern'
....
====
endif::show_solutions[]

== QGIS Exercise

The "specialty" of a GIS should of course not only be thought in theory. In 
this chapter you will perform some thematic and spatial queries.

=== Learning objectives

At the end of this exercise. you've mastered the following points:

* Select elements based on from thematic and spatial criteria
* Calculate a new value for a field from existing values

=== Thematic selection

At the beginning of this exercise we would like to perform a simple query that 
you already know from the SQL exercise in the theory part:

_You should select every lake which has a surface area above 20 km^2^ and a_
_lie below 400 meter above sea-level._

You could look through each cell in the Attributable and check which ones fit 
the criteria and which do not. However, if you have a large table that becomes 
rather time intensive.

It's simpler to use the prepared search interface. For simple searches like a 
name it's easiest to use _Field Filter_ in the table.

Try this method in a small example. Open the attribute table for lakes. In the 
lower left area you see a line on which _Show All Features_ is written and a 
menu, that you can unfold. Search in this menu, in the _Field Filter_, for the 
attribute, after which you want to sort out. In addition, you must enter the 
term, you want to filter by. You want now for example search for all lakes, in 
which the name "Lago" appears. Choose the attribute "name". in the menu and 
search for the term Lago.

So you can see right away, how many elements were selected, you can activate 
the option _Show Selected Features_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
task 4_ +
How many solutions
Do you get?_

ifdef::show_solutions[]
====
.Solution
Query:

.Input in QGIS
image::einfuehrung_in_qgis/aufgabe4abfrage.png["Aufgabe 4 Abfrage", 612, 36]

Solution:

.The returned entries in QGIS
image::einfuehrung_in_qgis/aufgabe4ausgabe.png["Aufgabe 4 Ausgabe", 629, 71]
====
endif::show_solutions[]

However, let us get back to the initial example. This query is a little more 
complicated. Open by clicking on the button _Select features using an_
_expression_ the query editor. Here the query can be formulated in the form of 
a _SQL_ query. However, only the _Where clause_ of the _SQL_ query can be 
inserted. From _Select * from lakes where max_depth > 100_ so only _max_depth 
> 100_ can be written into the query field

The single components of the Where-Expression can be put together, via 
double-click on the windows to the right.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 5_ +
_Formulate the where-clause of the SQL query for the initial task and run the 
query. How many lakes meet these conditions?_

ifdef::show_solutions[]
====
.Solution
....
SELECT
FROM lakes
WHERE Surface area > 20 AND Meters over seal level < 400
....
4 Seen
====
endif::show_solutions[]

=== Spatial selection

In the first part of this section a query was created based on values from 
the attribute table. Now a query should be run which takes the position of the 
object into consideration, also called spatial selection.


You can find the tools for the spartial queries when you click on the button 
_Toolbox_ and selecting _Select by location_ from _Vector selection_

All the cantons should be selected, which contain at least on of the found 
lakes completely. (i.e. the canton doesn't share the lake with another canton 
or country.) 

The _Select features from_ Layer gives information from which layer we select 
the elements. In this case we select from cantons and because of that we 
choose the layer canton boarders. The lakes are noted in the _By comparing to 
the features from_ layer. Check the box _Selected features only_ so that only 
the correct lakes are selected.

The lakes should be completely within the boarders of a canton. I.e. the 
cantonal areas contain the lake areas. Therefore the topological operation 
_contains_. By selecting torpological operations one always takes from _Select_
_features from_ and checks how it compares to _By comparing to the features_
_from_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_.Exercise 6_ +
_Run the query. How many cantons fulfill the condition?

ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe6abfrage.png["Aufgabe 6 Abfrage", 470, 374]

Lösung:

.Tabel output from QGIS
image::einfuehrung_in_qgis/aufgabe6ausgabe.png["Aufgabe 6 Ausgabe", 828, 189]

8 cantons meet the condition: Bern, Freiburg, Luzern, Obwalden, Schwyz, Waadt, 
Zug und Zürich.
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_.Exercise 7_ +
_How would you need to modify the query if all lakes should be selected which_
_are part of more than one canton or country?_
ifdef::show_solutions[]
====
.Solution
Query:

.Topological query window QGIS
image::einfuehrung_in_qgis/aufgabe7abfrage.png["Aufgabe 7 Abfrage", 470, 374]
====
endif::show_solutions[]

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_.Exercise 8_ +
_How many lakes meet the condition._

ifdef::show_solutions[]
====
.Solution
Result:

.Output in the table from QGIS
image::einfuehrung_in_qgis/aufgabe8ausgabe.png["Aufgabe 8 Abfrage", 627, 296]

12 Lakes meet the condition.
====
endif::show_solutions[]

=== Calculate fields

Next a new value can be generated, with the help of of existing attributes. In 
this case the population density of the cantons using the following formula:


_Population density per km^2^ = Number of inhabitants / Surface area in km^2^_

For this calculation we'll need the attribute table of the cantons. Select the 
option _Open field calculator_. If you want to use the density value into an 
existing column you can check _Update existing field_ in the mask and in the 
drop down menu select your desired column. In our case, however, we would like 
to create a new field. Therefore enter _Output field name_ enter the term 
_density_. Select as _Output field type Integer (integer)_ and as _Output_ 
_field length 10_.

If you want to calculate the density value for all and not only for the 
selected cantons, You have to be careful, that _Only update x selected_ 
_features_ is not checked.

Now you can use the _Field Calculator Expression_ according to the formula for 
the population density. All you have to do is put in the expression after the 
equal sign.

We would also like to calculate the density as a whole rounded number without 
decimal point. Therefore the option to _Whole number_ can be selected.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 9_ +
_What do you write into the calculator?_

ifdef::show_solutions[]
====
.Solution
to int ( Population / Surface area)
====
endif::show_solutions[]

After the calculation the editing mode must be switched off again. If you are 
satisfied with the calculation then save the changes. If not reject them.

=== Combined selection

Determine in another query the names of all major locations, their associated 
cantons which have a population density of more than than 200 inhabitants per 
km^2^ and have joined Switzerland between 1800 and 1900.

Now a query should be executed, in which both thematic and spartial components 
are involved.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 10_ +
_Think about which component is thematic and which is spartial._

ifdef::show_solutions[]
====
.Solution
*thematic:*

* Population density of more than 200 inhabitants per km^2^
* joined Switzerland between 1800 and 1900

*spartial:* +
Main towns located in the corresponding cantons.
====
endif::show_solutions[]

for this query we'll do two steps in the first one we'll run the thematic 
query. Open for that the attribute table for cantons and select with help of 
_Select by expression_ all cantons with the population density greater than 
200 people per km^2^ and joined Switzerland between 1800 and 1900.

mage:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 11_ +
_How goes the where-expression?_

ifdef::show_solutions[]
====
.Solution
....
WHERE Density > 200 AND accession year > 1800 AND accession year < 1900
....
====
endif::show_solutions[]

Now all cantons are selected which fulfill this condition.

After that we need to find the corresponding the main towns, this is done with 
the help of spartial selection. For that you open the tool _Select by Location_.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 12_ +
_Which layer is now the *Select features from*-Layer and which one the *By 
comparing to the features from*-Layer? Which Topological Surgery should be 
chosen?_

ifdef::show_solutions[]
====
.Solution
*Select features from:* main towns +
*By comparing to
the features from:* canton borders +

*Topologische Operation:* within
====
endif::show_solutions[]

Before the execution of the query check, that the attitudes are set so, that 
from the cantonal borders only the selected ones are taken into account.

image:einfuehrung_in_qgis/ausrufezeichen.png[, 15, 15]
_Exercise 13_ +
_Which main towns are the result?_

ifdef::show_solutions[]
====
.Solution
Aarau, Frauenfeld, Genève, Lausanne, Neuchâtel, Sankt Gallen
====
endif::show_solutions[]

== Chapter test 4

=== Question 1

In chapter 4 you have learned to differentiate between to variants of analysis 
namely queries and manipulations.

_What's the difference between this two variants._

Write down your answer using your own words and add an example for each.

ifdef::show_solutions[]
====
.Solution
Query: +
A query only accesses the data and does not change it in any form 

For example if you want to know how many people under 30 earn more than 
150'000 CHF per year

Manipulation: +
Manipulation changes or even adds new data.

For example: In an existing transport system you can add a new attribute that 
shows how strong the strain on it is. Another option would be the adding of 
yet untracked routs.
====
endif::show_solutions[]

== Question 2

You have learned to formulate thematic queries with SQL.

_Create an SQL query for the following question:_+
_"Which cantons have a greater population density than 200 people per km^2^, 
joined Switzerland before the year 1600 and whose name doesn't start with a Z?_


Use the simplified version of the SQL-guery and mark the typical elements of 
it separately. The names of the tables and Attributes can be taken from the 
data given to you.

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton +
WHERE Population / Surface area >
200 AND accession year < 1600
AND Name NOT LIKE ‘Z%’
====
endif::show_solutions[]

=== Question 3

Besides the thematic queries, there are other variants which can be combined.

_For the following question create an SQL-Query:_ +
_"Select all cantons which joined Switzerland after 1600 and have contact with 
a lake greater then 50km^2^._

ifdef::show_solutions[]
====
.Solution
SELECT * +
FROM canton, lake +
WHERE canton.accession year >
1600 AND lake.Surface area > 50
AND -- TODO
====
endif::show_solutions[]
